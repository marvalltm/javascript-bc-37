{"mappings":"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","sources":["node_modules/@parcel/runtime-browser-hmr/lib/runtime-9d875b4238f7f696.js","src/js/slider.js","node_modules/embla-carousel/embla-carousel.esm.js","node_modules/embla-carousel/src/components/utils.ts","node_modules/embla-carousel/src/components/Alignment.ts","node_modules/embla-carousel/src/components/Animation.ts","node_modules/embla-carousel/src/components/Axis.ts","node_modules/embla-carousel/src/components/Limit.ts","node_modules/embla-carousel/src/components/Counter.ts","node_modules/embla-carousel/src/components/Direction.ts","node_modules/embla-carousel/src/components/EventStore.ts","node_modules/embla-carousel/src/components/Vector1d.ts","node_modules/embla-carousel/src/components/DragHandler.ts","node_modules/embla-carousel/src/components/DragTracker.ts","node_modules/embla-carousel/src/components/PercentOfView.ts","node_modules/embla-carousel/src/components/ScrollBody.ts","node_modules/embla-carousel/src/components/ScrollBounds.ts","node_modules/embla-carousel/src/components/ScrollContain.ts","node_modules/embla-carousel/src/components/ScrollLimit.ts","node_modules/embla-carousel/src/components/ScrollLooper.ts","node_modules/embla-carousel/src/components/ScrollProgress.ts","node_modules/embla-carousel/src/components/ScrollSnaps.ts","node_modules/embla-carousel/src/components/ScrollTarget.ts","node_modules/embla-carousel/src/components/ScrollTo.ts","node_modules/embla-carousel/src/components/Translate.ts","node_modules/embla-carousel/src/components/SlideLooper.ts","node_modules/embla-carousel/src/components/SlidesInView.ts","node_modules/embla-carousel/src/components/SlideSizes.ts","node_modules/embla-carousel/src/components/SlidesToScroll.ts","node_modules/embla-carousel/src/components/Engine.ts","node_modules/embla-carousel/src/components/EventHandler.ts","node_modules/embla-carousel/src/components/Options.ts","node_modules/embla-carousel/src/components/OptionsHandler.ts","node_modules/embla-carousel/src/components/PluginsHandler.ts","node_modules/embla-carousel/src/components/index.ts"],"sourcesContent":["var HMR_HOST = null;var HMR_PORT = null;var HMR_SECURE = false;var HMR_ENV_HASH = \"d6ea1d42532a7575\";module.bundle.HMR_BUNDLE_ID = \"136dd88705ef630e\";\"use strict\";\n\n/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, globalThis, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */\n\n/*::\nimport type {\n  HMRAsset,\n  HMRMessage,\n} from '@parcel/reporter-dev-server/src/HMRServer.js';\ninterface ParcelRequire {\n  (string): mixed;\n  cache: {|[string]: ParcelModule|};\n  hotData: mixed;\n  Module: any;\n  parent: ?ParcelRequire;\n  isParcelRequire: true;\n  modules: {|[string]: [Function, {|[string]: string|}]|};\n  HMR_BUNDLE_ID: string;\n  root: ParcelRequire;\n}\ninterface ParcelModule {\n  hot: {|\n    data: mixed,\n    accept(cb: (Function) => void): void,\n    dispose(cb: (mixed) => void): void,\n    // accept(deps: Array<string> | string, cb: (Function) => void): void,\n    // decline(): void,\n    _acceptCallbacks: Array<(Function) => void>,\n    _disposeCallbacks: Array<(mixed) => void>,\n  |};\n}\ninterface ExtensionContext {\n  runtime: {|\n    reload(): void,\n    getURL(url: string): string;\n    getManifest(): {manifest_version: number, ...};\n  |};\n}\ndeclare var module: {bundle: ParcelRequire, ...};\ndeclare var HMR_HOST: string;\ndeclare var HMR_PORT: string;\ndeclare var HMR_ENV_HASH: string;\ndeclare var HMR_SECURE: boolean;\ndeclare var chrome: ExtensionContext;\ndeclare var browser: ExtensionContext;\ndeclare var __parcel__import__: (string) => Promise<void>;\ndeclare var __parcel__importScripts__: (string) => Promise<void>;\ndeclare var globalThis: typeof self;\ndeclare var ServiceWorkerGlobalScope: Object;\n*/\nvar OVERLAY_ID = '__parcel__error__overlay__';\nvar OldModule = module.bundle.Module;\n\nfunction Module(moduleName) {\n  OldModule.call(this, moduleName);\n  this.hot = {\n    data: module.bundle.hotData,\n    _acceptCallbacks: [],\n    _disposeCallbacks: [],\n    accept: function (fn) {\n      this._acceptCallbacks.push(fn || function () {});\n    },\n    dispose: function (fn) {\n      this._disposeCallbacks.push(fn);\n    }\n  };\n  module.bundle.hotData = undefined;\n}\n\nmodule.bundle.Module = Module;\nvar checkedAssets\n/*: {|[string]: boolean|} */\n, acceptedAssets\n/*: {|[string]: boolean|} */\n, assetsToAccept\n/*: Array<[ParcelRequire, string]> */\n;\n\nfunction getHostname() {\n  return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');\n}\n\nfunction getPort() {\n  return HMR_PORT || location.port;\n} // eslint-disable-next-line no-redeclare\n\n\nvar parent = module.bundle.parent;\n\nif ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {\n  var hostname = getHostname();\n  var port = getPort();\n  var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';\n  var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/'); // Web extension context\n\n  var extCtx = typeof chrome === 'undefined' ? typeof browser === 'undefined' ? null : browser : chrome; // Safari doesn't support sourceURL in error stacks.\n  // eval may also be disabled via CSP, so do a quick check.\n\n  var supportsSourceURL = false;\n\n  try {\n    (0, eval)('throw new Error(\"test\"); //# sourceURL=test.js');\n  } catch (err) {\n    supportsSourceURL = err.stack.includes('test.js');\n  } // $FlowFixMe\n\n\n  ws.onmessage = async function (event\n  /*: {data: string, ...} */\n  ) {\n    checkedAssets = {}\n    /*: {|[string]: boolean|} */\n    ;\n    acceptedAssets = {}\n    /*: {|[string]: boolean|} */\n    ;\n    assetsToAccept = [];\n    var data\n    /*: HMRMessage */\n    = JSON.parse(event.data);\n\n    if (data.type === 'update') {\n      // Remove error overlay if there is one\n      if (typeof document !== 'undefined') {\n        removeErrorOverlay();\n      }\n\n      let assets = data.assets.filter(asset => asset.envHash === HMR_ENV_HASH); // Handle HMR Update\n\n      let handled = assets.every(asset => {\n        return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);\n      });\n\n      if (handled) {\n        console.clear(); // Dispatch custom event so other runtimes (e.g React Refresh) are aware.\n\n        if (typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') {\n          window.dispatchEvent(new CustomEvent('parcelhmraccept'));\n        }\n\n        await hmrApplyUpdates(assets);\n\n        for (var i = 0; i < assetsToAccept.length; i++) {\n          var id = assetsToAccept[i][1];\n\n          if (!acceptedAssets[id]) {\n            hmrAcceptRun(assetsToAccept[i][0], id);\n          }\n        }\n      } else fullReload();\n    }\n\n    if (data.type === 'error') {\n      // Log parcel errors to console\n      for (let ansiDiagnostic of data.diagnostics.ansi) {\n        let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;\n        console.error(' [parcel]: ' + ansiDiagnostic.message + '\\n' + stack + '\\n\\n' + ansiDiagnostic.hints.join('\\n'));\n      }\n\n      if (typeof document !== 'undefined') {\n        // Render the fancy html overlay\n        removeErrorOverlay();\n        var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe\n\n        document.body.appendChild(overlay);\n      }\n    }\n  };\n\n  ws.onerror = function (e) {\n    console.error(e.message);\n  };\n\n  ws.onclose = function () {\n    console.warn('[parcel]  Connection to the HMR server was lost');\n  };\n}\n\nfunction removeErrorOverlay() {\n  var overlay = document.getElementById(OVERLAY_ID);\n\n  if (overlay) {\n    overlay.remove();\n    console.log('[parcel]  Error resolved');\n  }\n}\n\nfunction createErrorOverlay(diagnostics) {\n  var overlay = document.createElement('div');\n  overlay.id = OVERLAY_ID;\n  let errorHTML = '<div style=\"background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;\">';\n\n  for (let diagnostic of diagnostics) {\n    let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame) => {\n      return `${p}\n<a href=\"/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}\" style=\"text-decoration: underline; color: #888\" onclick=\"fetch(this.href); return false\">${frame.location}</a>\n${frame.code}`;\n    }, '') : diagnostic.stack;\n    errorHTML += `\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n           ${diagnostic.message}\n        </div>\n        <pre>${stack}</pre>\n        <div>\n          ${diagnostic.hints.map(hint => '<div> ' + hint + '</div>').join('')}\n        </div>\n        ${diagnostic.documentation ? `<div> <a style=\"color: violet\" href=\"${diagnostic.documentation}\" target=\"_blank\">Learn more</a></div>` : ''}\n      </div>\n    `;\n  }\n\n  errorHTML += '</div>';\n  overlay.innerHTML = errorHTML;\n  return overlay;\n}\n\nfunction fullReload() {\n  if ('reload' in location) {\n    location.reload();\n  } else if (extCtx && extCtx.runtime && extCtx.runtime.reload) {\n    extCtx.runtime.reload();\n  }\n}\n\nfunction getParents(bundle, id)\n/*: Array<[ParcelRequire, string]> */\n{\n  var modules = bundle.modules;\n\n  if (!modules) {\n    return [];\n  }\n\n  var parents = [];\n  var k, d, dep;\n\n  for (k in modules) {\n    for (d in modules[k][1]) {\n      dep = modules[k][1][d];\n\n      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {\n        parents.push([bundle, k]);\n      }\n    }\n  }\n\n  if (bundle.parent) {\n    parents = parents.concat(getParents(bundle.parent, id));\n  }\n\n  return parents;\n}\n\nfunction updateLink(link) {\n  var newLink = link.cloneNode();\n\n  newLink.onload = function () {\n    if (link.parentNode !== null) {\n      // $FlowFixMe\n      link.parentNode.removeChild(link);\n    }\n  };\n\n  newLink.setAttribute('href', // $FlowFixMe\n  link.getAttribute('href').split('?')[0] + '?' + Date.now()); // $FlowFixMe\n\n  link.parentNode.insertBefore(newLink, link.nextSibling);\n}\n\nvar cssTimeout = null;\n\nfunction reloadCSS() {\n  if (cssTimeout) {\n    return;\n  }\n\n  cssTimeout = setTimeout(function () {\n    var links = document.querySelectorAll('link[rel=\"stylesheet\"]');\n\n    for (var i = 0; i < links.length; i++) {\n      // $FlowFixMe[incompatible-type]\n      var href\n      /*: string */\n      = links[i].getAttribute('href');\n      var hostname = getHostname();\n      var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\\\/\\\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());\n      var absolute = /^https?:\\/\\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;\n\n      if (!absolute) {\n        updateLink(links[i]);\n      }\n    }\n\n    cssTimeout = null;\n  }, 50);\n}\n\nfunction hmrDownload(asset) {\n  if (asset.type === 'js') {\n    if (typeof document !== 'undefined') {\n      let script = document.createElement('script');\n      script.src = asset.url + '?t=' + Date.now();\n\n      if (asset.outputFormat === 'esmodule') {\n        script.type = 'module';\n      }\n\n      return new Promise((resolve, reject) => {\n        var _document$head;\n\n        script.onload = () => resolve(script);\n\n        script.onerror = reject;\n        (_document$head = document.head) === null || _document$head === void 0 ? void 0 : _document$head.appendChild(script);\n      });\n    } else if (typeof importScripts === 'function') {\n      // Worker scripts\n      if (asset.outputFormat === 'esmodule') {\n        return __parcel__import__(asset.url + '?t=' + Date.now());\n      } else {\n        return new Promise((resolve, reject) => {\n          try {\n            __parcel__importScripts__(asset.url + '?t=' + Date.now());\n\n            resolve();\n          } catch (err) {\n            reject(err);\n          }\n        });\n      }\n    }\n  }\n}\n\nasync function hmrApplyUpdates(assets) {\n  global.parcelHotUpdate = Object.create(null);\n  let scriptsToRemove;\n\n  try {\n    // If sourceURL comments aren't supported in eval, we need to load\n    // the update from the dev server over HTTP so that stack traces\n    // are correct in errors/logs. This is much slower than eval, so\n    // we only do it if needed (currently just Safari).\n    // https://bugs.webkit.org/show_bug.cgi?id=137297\n    // This path is also taken if a CSP disallows eval.\n    if (!supportsSourceURL) {\n      let promises = assets.map(asset => {\n        var _hmrDownload;\n\n        return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch(err => {\n          // Web extension bugfix for Chromium\n          // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12\n          if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {\n            if (typeof ServiceWorkerGlobalScope != 'undefined' && global instanceof ServiceWorkerGlobalScope) {\n              extCtx.runtime.reload();\n              return;\n            }\n\n            asset.url = extCtx.runtime.getURL('/__parcel_hmr_proxy__?url=' + encodeURIComponent(asset.url + '?t=' + Date.now()));\n            return hmrDownload(asset);\n          }\n\n          throw err;\n        });\n      });\n      scriptsToRemove = await Promise.all(promises);\n    }\n\n    assets.forEach(function (asset) {\n      hmrApply(module.bundle.root, asset);\n    });\n  } finally {\n    delete global.parcelHotUpdate;\n\n    if (scriptsToRemove) {\n      scriptsToRemove.forEach(script => {\n        if (script) {\n          var _document$head2;\n\n          (_document$head2 = document.head) === null || _document$head2 === void 0 ? void 0 : _document$head2.removeChild(script);\n        }\n      });\n    }\n  }\n}\n\nfunction hmrApply(bundle\n/*: ParcelRequire */\n, asset\n/*:  HMRAsset */\n) {\n  var modules = bundle.modules;\n\n  if (!modules) {\n    return;\n  }\n\n  if (asset.type === 'css') {\n    reloadCSS();\n  } else if (asset.type === 'js') {\n    let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];\n\n    if (deps) {\n      if (modules[asset.id]) {\n        // Remove dependencies that are removed and will become orphaned.\n        // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.\n        let oldDeps = modules[asset.id][1];\n\n        for (let dep in oldDeps) {\n          if (!deps[dep] || deps[dep] !== oldDeps[dep]) {\n            let id = oldDeps[dep];\n            let parents = getParents(module.bundle.root, id);\n\n            if (parents.length === 1) {\n              hmrDelete(module.bundle.root, id);\n            }\n          }\n        }\n      }\n\n      if (supportsSourceURL) {\n        // Global eval. We would use `new Function` here but browser\n        // support for source maps is better with eval.\n        (0, eval)(asset.output);\n      } // $FlowFixMe\n\n\n      let fn = global.parcelHotUpdate[asset.id];\n      modules[asset.id] = [fn, deps];\n    } else if (bundle.parent) {\n      hmrApply(bundle.parent, asset);\n    }\n  }\n}\n\nfunction hmrDelete(bundle, id) {\n  let modules = bundle.modules;\n\n  if (!modules) {\n    return;\n  }\n\n  if (modules[id]) {\n    // Collect dependencies that will become orphaned when this module is deleted.\n    let deps = modules[id][1];\n    let orphans = [];\n\n    for (let dep in deps) {\n      let parents = getParents(module.bundle.root, deps[dep]);\n\n      if (parents.length === 1) {\n        orphans.push(deps[dep]);\n      }\n    } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.\n\n\n    delete modules[id];\n    delete bundle.cache[id]; // Now delete the orphans.\n\n    orphans.forEach(id => {\n      hmrDelete(module.bundle.root, id);\n    });\n  } else if (bundle.parent) {\n    hmrDelete(bundle.parent, id);\n  }\n}\n\nfunction hmrAcceptCheck(bundle\n/*: ParcelRequire */\n, id\n/*: string */\n, depsByBundle\n/*: ?{ [string]: { [string]: string } }*/\n) {\n  if (hmrAcceptCheckOne(bundle, id, depsByBundle)) {\n    return true;\n  } // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.\n\n\n  let parents = getParents(module.bundle.root, id);\n  let accepted = false;\n\n  while (parents.length > 0) {\n    let v = parents.shift();\n    let a = hmrAcceptCheckOne(v[0], v[1], null);\n\n    if (a) {\n      // If this parent accepts, stop traversing upward, but still consider siblings.\n      accepted = true;\n    } else {\n      // Otherwise, queue the parents in the next level upward.\n      let p = getParents(module.bundle.root, v[1]);\n\n      if (p.length === 0) {\n        // If there are no parents, then we've reached an entry without accepting. Reload.\n        accepted = false;\n        break;\n      }\n\n      parents.push(...p);\n    }\n  }\n\n  return accepted;\n}\n\nfunction hmrAcceptCheckOne(bundle\n/*: ParcelRequire */\n, id\n/*: string */\n, depsByBundle\n/*: ?{ [string]: { [string]: string } }*/\n) {\n  var modules = bundle.modules;\n\n  if (!modules) {\n    return;\n  }\n\n  if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {\n    // If we reached the root bundle without finding where the asset should go,\n    // there's nothing to do. Mark as \"accepted\" so we don't reload the page.\n    if (!bundle.parent) {\n      return true;\n    }\n\n    return hmrAcceptCheck(bundle.parent, id, depsByBundle);\n  }\n\n  if (checkedAssets[id]) {\n    return true;\n  }\n\n  checkedAssets[id] = true;\n  var cached = bundle.cache[id];\n  assetsToAccept.push([bundle, id]);\n\n  if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {\n    return true;\n  }\n}\n\nfunction hmrAcceptRun(bundle\n/*: ParcelRequire */\n, id\n/*: string */\n) {\n  var cached = bundle.cache[id];\n  bundle.hotData = {};\n\n  if (cached && cached.hot) {\n    cached.hot.data = bundle.hotData;\n  }\n\n  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {\n    cached.hot._disposeCallbacks.forEach(function (cb) {\n      cb(bundle.hotData);\n    });\n  }\n\n  delete bundle.cache[id];\n  bundle(id);\n  cached = bundle.cache[id];\n\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    cached.hot._acceptCallbacks.forEach(function (cb) {\n      var assetsToAlsoAccept = cb(function () {\n        return getParents(module.bundle.root, id);\n      });\n\n      if (assetsToAlsoAccept && assetsToAccept.length) {\n        // $FlowFixMe[method-unbinding]\n        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);\n      }\n    });\n  }\n\n  acceptedAssets[id] = true;\n}","//https://www.embla-carousel.com/get-started/module/\r\n\r\n//https://codesandbox.io/s/embla-carousel-dragfree-vanilla-y1rnu?file=/src/js/prevAndNextButtons.js\r\nimport EmblaCarousel from 'embla-carousel';\r\n\r\nconst onThumbClick = (mainCarousel, thumbCarousel, index) => () => {\r\n  if (!thumbCarousel.clickAllowed()) return;\r\n  mainCarousel.scrollTo(index);\r\n};\r\n\r\nconst followMainCarousel = (mainCarousel, thumbCarousel) => () => {\r\n  thumbCarousel.scrollTo(mainCarousel.selectedScrollSnap());\r\n  selectThumbBtn(mainCarousel, thumbCarousel);\r\n};\r\n\r\nconst selectThumbBtn = (mainCarousel, thumbCarousel) => {\r\n  const previous = mainCarousel.previousScrollSnap();\r\n  const selected = mainCarousel.selectedScrollSnap();\r\n  thumbCarousel.slideNodes()[previous].classList.remove('is-selected');\r\n  thumbCarousel.slideNodes()[selected].classList.add('is-selected');\r\n};\r\n\r\n//=========================================================\r\nconst mainCarouselWrap = document.getElementById('main-carousel');\r\nconst mainCarouselView = mainCarouselWrap.querySelector('.embla__viewport');\r\nconst mainCarousel = EmblaCarousel(mainCarouselView, {\r\n  selectedClass: '',\r\n  loop: false,\r\n  skipSnaps: false,\r\n});\r\n\r\nconst thumbCarouselWrap = document.getElementById('thumb-carousel');\r\nconst thumbCarouselView = thumbCarouselWrap.querySelector('.embla__viewport');\r\nconst thumbCarousel = EmblaCarousel(thumbCarouselView, {\r\n  selectedClass: '',\r\n  containScroll: 'keepSnaps',\r\n  dragFree: true,\r\n});\r\n\r\nthumbCarousel.slideNodes().forEach((thumbNode, index) => {\r\n  const onClick = onThumbClick(mainCarousel, thumbCarousel, index);\r\n  thumbNode.addEventListener('click', onClick, false);\r\n});\r\n\r\nconst syncThumbCarousel = followMainCarousel(mainCarousel, thumbCarousel);\r\nmainCarousel.on('select', syncThumbCarousel);\r\nthumbCarousel.on('init', syncThumbCarousel);\r\n",null,"export function map(\n  value: number,\n  iStart: number,\n  iStop: number,\n  oStart: number,\n  oStop: number,\n): number {\n  return oStart + (oStop - oStart) * ((value - iStart) / (iStop - iStart))\n}\n\nexport function isNumber(subject: unknown): subject is number {\n  return typeof subject === 'number'\n}\n\nexport function isObject(subject: unknown): subject is Record<string, unknown> {\n  return Object.prototype.toString.call(subject) === '[object Object]'\n}\n\nexport function isArray(subject: unknown): subject is Record<number, unknown> {\n  return Array.isArray(subject)\n}\n\nexport function isRecord(\n  subject: unknown,\n): subject is Record<string | number, unknown> {\n  return isObject(subject) || isArray(subject)\n}\n\nexport function mathAbs(n: number): number {\n  return Math.abs(n)\n}\n\nexport function mathSign(n: number): number {\n  return !n ? 0 : n / mathAbs(n)\n}\n\nexport function deltaAbs(valueB: number, valueA: number): number {\n  return mathAbs(valueB - valueA)\n}\n\nexport function factorAbs(valueB: number, valueA: number): number {\n  if (valueB === 0 || valueA === 0) return 0\n  if (mathAbs(valueB) <= mathAbs(valueA)) return 0\n  const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA))\n  return mathAbs(diff / valueB)\n}\n\nexport function roundToDecimals(decimalPoints: number): (n: number) => number {\n  const pow = Math.pow(10, decimalPoints)\n  return (n: number): number => Math.round(n * pow) / pow\n}\n\nexport function arrayKeys<Type>(array: Type[]): number[] {\n  return objectKeys(array).map(Number)\n}\n\nexport function arrayLast<Type>(array: Type[]): Type {\n  return array[arrayLastIndex(array)]\n}\n\nexport function arrayLastIndex<Type>(array: Type[]): number {\n  return Math.max(0, array.length - 1)\n}\n\nexport function objectKeys<Type>(object: Type): string[] {\n  return Object.keys(object)\n}\n\nexport function objectsMergeDeep(\n  objectA: Record<string, unknown>,\n  objectB: Record<string, unknown>,\n): Record<string, unknown> {\n  return [objectA, objectB].reduce((mergedObjects, currentObject) => {\n    objectKeys(currentObject).forEach((key) => {\n      const valueA = mergedObjects[key]\n      const valueB = currentObject[key]\n      const areObjects = isObject(valueA) && isObject(valueB)\n\n      mergedObjects[key] = areObjects\n        ? objectsMergeDeep(valueA, valueB)\n        : valueB\n    })\n    return mergedObjects\n  }, {})\n}\n\nexport function objectsAreEqual(\n  objectA: Record<string, unknown>,\n  objectB: Record<string, unknown>,\n): boolean {\n  const objectAKeys = objectKeys(objectA)\n  const objectBKeys = objectKeys(objectB)\n\n  if (objectAKeys.length !== objectBKeys.length) return false\n\n  return objectAKeys.every((key) => {\n    const valueA = objectA[key]\n    const valueB = objectB[key]\n    if (typeof valueA === 'function') return `${valueA}` === `${valueB}`\n    if (!isRecord(valueA) || !isRecord(valueB)) return valueA === valueB\n    return objectsAreEqual(valueA, valueB)\n  })\n}\n","import { isNumber } from './utils'\n\nexport type AlignmentOptionType = 'start' | 'center' | 'end' | number\n\nexport type AlignmentType = {\n  measure: (n: number) => number\n}\n\nexport function Alignment(\n  align: AlignmentOptionType,\n  viewSize: number,\n): AlignmentType {\n  const predefined = { start, center, end }\n\n  function start(): number {\n    return 0\n  }\n\n  function center(n: number): number {\n    return end(n) / 2\n  }\n\n  function end(n: number): number {\n    return viewSize - n\n  }\n\n  function percent(): number {\n    return viewSize * Number(align)\n  }\n\n  function measure(n: number): number {\n    if (isNumber(align)) return percent()\n    return predefined[align](n)\n  }\n\n  const self: AlignmentType = {\n    measure,\n  }\n  return self\n}\n","type CallbackType = () => void\n\nexport type AnimationType = {\n  start: () => void\n  stop: () => void\n  proceed: () => void\n}\n\nexport function Animation(callback: FrameRequestCallback): AnimationType {\n  let animationFrame = 0\n\n  function ifAnimating(active: boolean, cb: CallbackType): CallbackType {\n    return (): void => {\n      if (active === !!animationFrame) cb()\n    }\n  }\n\n  function start(): void {\n    animationFrame = window.requestAnimationFrame(callback)\n  }\n\n  function stop(): void {\n    window.cancelAnimationFrame(animationFrame)\n    animationFrame = 0\n  }\n\n  const self: AnimationType = {\n    proceed: ifAnimating(true, start),\n    start: ifAnimating(false, start),\n    stop: ifAnimating(true, stop),\n  }\n  return self\n}\n","import { DirectionOptionType } from './Direction'\n\nexport type AxisOptionType = 'x' | 'y'\ntype AxisEdgeType = 'top' | 'right' | 'bottom' | 'left'\n\nexport type AxisType = {\n  scroll: AxisOptionType\n  cross: AxisOptionType\n  startEdge: AxisEdgeType\n  endEdge: AxisEdgeType\n  measureSize: (rect: DOMRect) => number\n}\n\nexport function Axis(\n  axis: AxisOptionType,\n  direction: DirectionOptionType,\n): AxisType {\n  const scroll = axis === 'y' ? 'y' : 'x'\n  const cross = axis === 'y' ? 'x' : 'y'\n  const startEdge = getStartEdge()\n  const endEdge = getEndEdge()\n\n  function measureSize(rect: DOMRect): number {\n    const { width, height } = rect\n    return scroll === 'x' ? width : height\n  }\n\n  function getStartEdge(): AxisEdgeType {\n    if (scroll === 'y') return 'top'\n    return direction === 'rtl' ? 'right' : 'left'\n  }\n\n  function getEndEdge(): AxisEdgeType {\n    if (scroll === 'y') return 'bottom'\n    return direction === 'rtl' ? 'left' : 'right'\n  }\n\n  const self: AxisType = {\n    scroll,\n    cross,\n    startEdge,\n    endEdge,\n    measureSize,\n  }\n  return self\n}\n","import { mathAbs } from './utils'\n\nexport type LimitType = {\n  min: number\n  max: number\n  length: number\n  constrain: (n: number) => number\n  reachedAny: (n: number) => boolean\n  reachedMax: (n: number) => boolean\n  reachedMin: (n: number) => boolean\n  removeOffset: (n: number) => number\n}\n\nexport function Limit(min: number, max: number): LimitType {\n  const length = mathAbs(min - max)\n\n  function reachedMin(n: number): boolean {\n    return n < min\n  }\n\n  function reachedMax(n: number): boolean {\n    return n > max\n  }\n\n  function reachedAny(n: number): boolean {\n    return reachedMin(n) || reachedMax(n)\n  }\n\n  function constrain(n: number): number {\n    if (!reachedAny(n)) return n\n    return reachedMin(n) ? min : max\n  }\n\n  function removeOffset(n: number): number {\n    if (!length) return n\n    return n - length * Math.ceil((n - max) / length)\n  }\n\n  const self: LimitType = {\n    length,\n    max,\n    min,\n    constrain,\n    reachedAny,\n    reachedMax,\n    reachedMin,\n    removeOffset,\n  }\n  return self\n}\n","import { Limit } from './Limit'\nimport { mathAbs } from './utils'\n\nexport type CounterType = {\n  get: () => number\n  set: (n: number) => CounterType\n  add: (n: number) => CounterType\n  clone: () => CounterType\n  min: number\n  max: number\n}\n\nexport function Counter(\n  max: number,\n  start: number,\n  loop: boolean,\n): CounterType {\n  const { min, constrain } = Limit(0, max)\n  const loopEnd = max + 1\n  let counter = withinLimit(start)\n\n  function withinLimit(n: number): number {\n    return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd)\n  }\n\n  function get(): number {\n    return counter\n  }\n\n  function set(n: number): CounterType {\n    counter = withinLimit(n)\n    return self\n  }\n\n  function add(n: number): CounterType {\n    return set(get() + n)\n  }\n\n  function clone(): CounterType {\n    return Counter(max, get(), loop)\n  }\n\n  const self: CounterType = {\n    add,\n    clone,\n    get,\n    set,\n    min,\n    max,\n  }\n  return self\n}\n","export type DirectionOptionType = 'ltr' | 'rtl'\n\nexport type DirectionType = {\n  apply: (n: number) => number\n}\n\nexport function Direction(direction: DirectionOptionType): DirectionType {\n  const sign = direction === 'rtl' ? -1 : 1\n\n  function apply(n: number): number {\n    return n * sign\n  }\n\n  const self: DirectionType = {\n    apply,\n  }\n  return self\n}\n","type EventNameType = keyof DocumentEventMap | keyof WindowEventMap\ntype EventHandlerType = (evt: any) => void\ntype EventOptionsType = boolean | AddEventListenerOptions | undefined\ntype EventRemoverType = () => void\n\nexport type EventStoreType = {\n  add: (\n    node: EventTarget,\n    type: EventNameType,\n    handler: EventHandlerType,\n    options?: EventOptionsType,\n  ) => EventStoreType\n  removeAll: () => EventStoreType\n}\n\nexport function EventStore(): EventStoreType {\n  let listeners: EventRemoverType[] = []\n\n  function add(\n    node: EventTarget,\n    type: EventNameType,\n    handler: EventHandlerType,\n    options: EventOptionsType = false,\n  ): EventStoreType {\n    node.addEventListener(type, handler, options)\n    listeners.push(() => node.removeEventListener(type, handler, options))\n    return self\n  }\n\n  function removeAll(): EventStoreType {\n    listeners = listeners.filter((remove) => remove())\n    return self\n  }\n\n  const self: EventStoreType = {\n    add,\n    removeAll,\n  }\n  return self\n}\n","import { isNumber } from './utils'\n\nexport type Vector1DType = {\n  get: () => number\n  set: (v: Vector1DType | number) => Vector1DType\n  add: (v: Vector1DType | number) => Vector1DType\n  subtract: (v: Vector1DType | number) => Vector1DType\n  multiply: (n: number) => Vector1DType\n  divide: (n: number) => Vector1DType\n  normalize: () => Vector1DType\n}\n\nexport function Vector1D(value: number): Vector1DType {\n  let vector = value\n\n  function get(): number {\n    return vector\n  }\n\n  function set(n: Vector1DType | number): Vector1DType {\n    vector = readNumber(n)\n    return self\n  }\n\n  function add(n: Vector1DType | number): Vector1DType {\n    vector += readNumber(n)\n    return self\n  }\n\n  function subtract(n: Vector1DType | number): Vector1DType {\n    vector -= readNumber(n)\n    return self\n  }\n\n  function multiply(n: number): Vector1DType {\n    vector *= n\n    return self\n  }\n\n  function divide(n: number): Vector1DType {\n    vector /= n\n    return self\n  }\n\n  function normalize(): Vector1DType {\n    if (vector !== 0) divide(vector)\n    return self\n  }\n\n  function readNumber(n: Vector1DType | number): number {\n    return isNumber(n) ? n : n.get()\n  }\n\n  const self: Vector1DType = {\n    add,\n    divide,\n    get,\n    multiply,\n    normalize,\n    set,\n    subtract,\n  }\n  return self\n}\n","import { AnimationType } from './Animation'\nimport { CounterType } from './Counter'\nimport { DirectionType } from './Direction'\nimport { DragTrackerType, PointerEventType } from './DragTracker'\nimport { EventHandlerType } from './EventHandler'\nimport { AxisType } from './Axis'\nimport { EventStore } from './EventStore'\nimport { ScrollBodyType } from './ScrollBody'\nimport { ScrollTargetType } from './ScrollTarget'\nimport { ScrollToType } from './ScrollTo'\nimport { Vector1D, Vector1DType } from './Vector1d'\nimport { deltaAbs, factorAbs, mathAbs, mathSign } from './utils'\nimport { PercentOfViewType } from './PercentOfView'\n\nexport type DragHandlerType = {\n  addActivationEvents: () => void\n  clickAllowed: () => boolean\n  pointerDown: () => boolean\n  removeAllEvents: () => void\n}\n\nexport function DragHandler(\n  axis: AxisType,\n  direction: DirectionType,\n  rootNode: HTMLElement,\n  target: Vector1DType,\n  dragTracker: DragTrackerType,\n  location: Vector1DType,\n  animation: AnimationType,\n  scrollTo: ScrollToType,\n  scrollBody: ScrollBodyType,\n  scrollTarget: ScrollTargetType,\n  index: CounterType,\n  eventHandler: EventHandlerType,\n  percentOfView: PercentOfViewType,\n  loop: boolean,\n  dragFree: boolean,\n  skipSnaps: boolean,\n): DragHandlerType {\n  const { cross: crossAxis } = axis\n  const focusNodes = ['INPUT', 'SELECT', 'TEXTAREA']\n  const dragStartPoint = Vector1D(0)\n  const activationEvents = EventStore()\n  const interactionEvents = EventStore()\n  const dragThreshold = percentOfView.measure(20)\n  const snapForceBoost = { mouse: 300, touch: 400 }\n  const freeForceBoost = { mouse: 500, touch: 600 }\n  const baseSpeed = dragFree ? 5 : 16\n  const baseMass = 1\n\n  let startScroll = 0\n  let startCross = 0\n  let pointerIsDown = false\n  let preventScroll = false\n  let preventClick = false\n  let isMouse = false\n\n  function addActivationEvents(): void {\n    const node = rootNode\n    activationEvents\n      .add(node, 'touchmove', () => undefined)\n      .add(node, 'touchend', () => undefined)\n      .add(node, 'touchstart', down)\n      .add(node, 'mousedown', down)\n      .add(node, 'touchcancel', up)\n      .add(node, 'contextmenu', up)\n      .add(node, 'click', click)\n  }\n\n  function addInteractionEvents(): void {\n    const node = !isMouse ? rootNode : document\n    interactionEvents\n      .add(node, 'touchmove', move)\n      .add(node, 'touchend', up)\n      .add(node, 'mousemove', move)\n      .add(node, 'mouseup', up)\n  }\n\n  function removeAllEvents(): void {\n    activationEvents.removeAll()\n    interactionEvents.removeAll()\n  }\n\n  function isFocusNode(node: Element): boolean {\n    const name = node.nodeName || ''\n    return focusNodes.indexOf(name) > -1\n  }\n\n  function forceBoost(): number {\n    const boost = dragFree ? freeForceBoost : snapForceBoost\n    const type = isMouse ? 'mouse' : 'touch'\n    return boost[type]\n  }\n\n  function allowedForce(force: number, targetChanged: boolean): number {\n    const next = index.clone().add(mathSign(force) * -1)\n    const isEdge = next.get() === index.min || next.get() === index.max\n    const baseForce = scrollTarget.byDistance(force, !dragFree).distance\n\n    if (dragFree || mathAbs(force) < dragThreshold) return baseForce\n    if (!loop && isEdge) return baseForce * 0.4\n    if (skipSnaps && targetChanged) return baseForce * 0.5\n\n    return scrollTarget.byIndex(next.get(), 0).distance\n  }\n\n  function down(evt: PointerEventType): void {\n    isMouse = evt.type === 'mousedown'\n    if (isMouse && (evt as MouseEvent).button !== 0) return\n\n    const isMoving = deltaAbs(target.get(), location.get()) >= 2\n    const clearPreventClick = isMouse || !isMoving\n    const isNotFocusNode = !isFocusNode(evt.target as Element)\n    const preventDefault = isMoving || (isMouse && isNotFocusNode)\n\n    pointerIsDown = true\n    dragTracker.pointerDown(evt)\n    dragStartPoint.set(target)\n    target.set(location)\n    scrollBody.useBaseMass().useSpeed(80)\n    addInteractionEvents()\n    startScroll = dragTracker.readPoint(evt)\n    startCross = dragTracker.readPoint(evt, crossAxis)\n    eventHandler.emit('pointerDown')\n\n    if (clearPreventClick) preventClick = false\n    if (preventDefault) evt.preventDefault()\n  }\n\n  function move(evt: PointerEventType): void {\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable) return up(evt)\n      const lastScroll = dragTracker.readPoint(evt)\n      const lastCross = dragTracker.readPoint(evt, crossAxis)\n      const diffScroll = deltaAbs(lastScroll, startScroll)\n      const diffCross = deltaAbs(lastCross, startCross)\n      preventScroll = diffScroll > diffCross\n      if (!preventScroll && !preventClick) return up(evt)\n    }\n    const diff = dragTracker.pointerMove(evt)\n    if (!preventClick && diff) preventClick = true\n    animation.start()\n    target.add(direction.apply(diff))\n    evt.preventDefault()\n  }\n\n  function up(evt: PointerEventType): void {\n    const currentLocation = scrollTarget.byDistance(0, false)\n    const targetChanged = currentLocation.index !== index.get()\n    const rawForce = dragTracker.pointerUp(evt) * forceBoost()\n    const force = allowedForce(direction.apply(rawForce), targetChanged)\n    const forceFactor = factorAbs(rawForce, force)\n    const isMoving = deltaAbs(target.get(), dragStartPoint.get()) >= 0.5\n    const isVigorous = targetChanged && forceFactor > 0.75\n    const isBelowThreshold = mathAbs(rawForce) < dragThreshold\n    const speed = isVigorous ? 10 : baseSpeed\n    const mass = isVigorous ? baseMass + 2.5 * forceFactor : baseMass\n\n    if (isMoving && !isMouse) preventClick = true\n    preventScroll = false\n    pointerIsDown = false\n    interactionEvents.removeAll()\n    scrollBody.useSpeed(isBelowThreshold ? 9 : speed).useMass(mass)\n    scrollTo.distance(force, !dragFree)\n    isMouse = false\n    eventHandler.emit('pointerUp')\n  }\n\n  function click(evt: MouseEvent): void {\n    if (preventClick) evt.preventDefault()\n  }\n\n  function clickAllowed(): boolean {\n    return !preventClick\n  }\n\n  function pointerDown(): boolean {\n    return pointerIsDown\n  }\n\n  const self: DragHandlerType = {\n    addActivationEvents,\n    clickAllowed,\n    pointerDown,\n    removeAllEvents,\n  }\n  return self\n}\n","import { AxisOptionType, AxisType } from './Axis'\nimport { mathAbs } from './utils'\n\ntype PointerCoordType = keyof Touch | keyof MouseEvent\nexport type PointerEventType = TouchEvent | MouseEvent\n\nexport type DragTrackerType = {\n  isTouchEvent: (evt: PointerEventType) => evt is TouchEvent\n  pointerDown: (evt: PointerEventType) => number\n  pointerMove: (evt: PointerEventType) => number\n  pointerUp: (evt: PointerEventType) => number\n  readPoint: (evt: PointerEventType, evtAxis?: AxisOptionType) => number\n}\n\nexport function DragTracker(axis: AxisType): DragTrackerType {\n  const logInterval = 170\n\n  let startEvent: PointerEventType\n  let lastEvent: PointerEventType\n\n  function isTouchEvent(evt: PointerEventType): evt is TouchEvent {\n    return typeof TouchEvent !== 'undefined' && evt instanceof TouchEvent\n  }\n\n  function readTime(evt: PointerEventType): number {\n    return evt.timeStamp\n  }\n\n  function readPoint(evt: PointerEventType, evtAxis?: AxisOptionType): number {\n    const property = evtAxis || axis.scroll\n    const coord: PointerCoordType = `client${property === 'x' ? 'X' : 'Y'}`\n    return (isTouchEvent(evt) ? evt.touches[0] : evt)[coord]\n  }\n\n  function pointerDown(evt: PointerEventType): number {\n    startEvent = evt\n    lastEvent = evt\n    return readPoint(evt)\n  }\n\n  function pointerMove(evt: PointerEventType): number {\n    const diff = readPoint(evt) - readPoint(lastEvent)\n    const expired = readTime(evt) - readTime(startEvent) > logInterval\n\n    lastEvent = evt\n    if (expired) startEvent = evt\n    return diff\n  }\n\n  function pointerUp(evt: PointerEventType): number {\n    if (!startEvent || !lastEvent) return 0\n    const diffDrag = readPoint(lastEvent) - readPoint(startEvent)\n    const diffTime = readTime(evt) - readTime(startEvent)\n    const expired = readTime(evt) - readTime(lastEvent) > logInterval\n    const force = diffDrag / diffTime\n    const isFlick = diffTime && !expired && mathAbs(force) > 0.1\n\n    return isFlick ? force : 0\n  }\n\n  const self: DragTrackerType = {\n    isTouchEvent,\n    pointerDown,\n    pointerMove,\n    pointerUp,\n    readPoint,\n  }\n  return self\n}\n","export type PercentOfViewType = {\n  measure: (n: number) => number\n}\n\nexport function PercentOfView(viewSize: number): PercentOfViewType {\n  function measure(n: number): number {\n    return viewSize * (n / 100)\n  }\n\n  const self: PercentOfViewType = {\n    measure,\n  }\n  return self\n}\n","import { map, roundToDecimals, mathSign } from './utils'\nimport { Vector1D, Vector1DType } from './Vector1d'\n\nexport type ScrollBodyType = {\n  direction: () => number\n  seek: (target: Vector1DType) => ScrollBodyType\n  settle: (target: Vector1DType) => boolean\n  update: () => void\n  useBaseMass: () => ScrollBodyType\n  useBaseSpeed: () => ScrollBodyType\n  useMass: (n: number) => ScrollBodyType\n  useSpeed: (n: number) => ScrollBodyType\n}\n\nexport function ScrollBody(\n  location: Vector1DType,\n  baseSpeed: number,\n  baseMass: number,\n): ScrollBodyType {\n  const roundToTwoDecimals = roundToDecimals(2)\n  const velocity = Vector1D(0)\n  const acceleration = Vector1D(0)\n  const attraction = Vector1D(0)\n\n  let attractionDirection = 0\n  let speed = baseSpeed\n  let mass = baseMass\n\n  function update(): void {\n    velocity.add(acceleration)\n    location.add(velocity)\n    acceleration.multiply(0)\n  }\n\n  function applyForce(force: Vector1DType): void {\n    force.divide(mass)\n    acceleration.add(force)\n  }\n\n  function seek(target: Vector1DType): ScrollBodyType {\n    attraction.set(target).subtract(location)\n    const magnitude = map(attraction.get(), 0, 100, 0, speed)\n    attractionDirection = mathSign(attraction.get())\n    attraction.normalize().multiply(magnitude).subtract(velocity)\n    applyForce(attraction)\n    return self\n  }\n\n  function settle(target: Vector1DType): boolean {\n    const diff = target.get() - location.get()\n    const hasSettled = !roundToTwoDecimals(diff)\n    if (hasSettled) location.set(target)\n    return hasSettled\n  }\n\n  function direction(): number {\n    return attractionDirection\n  }\n\n  function useBaseSpeed(): ScrollBodyType {\n    return useSpeed(baseSpeed)\n  }\n\n  function useBaseMass(): ScrollBodyType {\n    return useMass(baseMass)\n  }\n\n  function useSpeed(n: number): ScrollBodyType {\n    speed = n\n    return self\n  }\n\n  function useMass(n: number): ScrollBodyType {\n    mass = n\n    return self\n  }\n\n  const self: ScrollBodyType = {\n    direction,\n    seek,\n    settle,\n    update,\n    useBaseMass,\n    useBaseSpeed,\n    useMass,\n    useSpeed,\n  }\n  return self\n}\n","import { LimitType } from './Limit'\nimport { ScrollBodyType } from './ScrollBody'\nimport { Vector1DType } from './Vector1d'\nimport { mathAbs } from './utils'\nimport { PercentOfViewType } from './PercentOfView'\n\nexport type ScrollBoundsType = {\n  constrain: (pointerDown: boolean) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function ScrollBounds(\n  limit: LimitType,\n  location: Vector1DType,\n  target: Vector1DType,\n  scrollBody: ScrollBodyType,\n  percentOfView: PercentOfViewType,\n): ScrollBoundsType {\n  const pullBackThreshold = percentOfView.measure(10)\n  const edgeOffsetTolerance = percentOfView.measure(50)\n  const maxFriction = 0.85\n  let disabled = false\n\n  function shouldConstrain(): boolean {\n    if (disabled) return false\n    if (!limit.reachedAny(target.get())) return false\n    if (!limit.reachedAny(location.get())) return false\n    return true\n  }\n\n  function constrain(pointerDown: boolean): void {\n    if (!shouldConstrain()) return\n    const edge = limit.reachedMin(location.get()) ? 'min' : 'max'\n    const diffToEdge = mathAbs(limit[edge] - location.get())\n    const diffToTarget = target.get() - location.get()\n    const friction = Math.min(diffToEdge / edgeOffsetTolerance, maxFriction)\n\n    target.subtract(diffToTarget * friction)\n\n    if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {\n      target.set(limit.constrain(target.get()))\n      scrollBody.useSpeed(10).useMass(3)\n    }\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  const self: ScrollBoundsType = {\n    constrain,\n    toggleActive,\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { arrayLast } from './utils'\n\nexport type ScrollContainOptionType = '' | 'trimSnaps' | 'keepSnaps'\n\nexport type ScrollContainType = {\n  snapsContained: number[]\n}\n\nexport function ScrollContain(\n  viewSize: number,\n  contentSize: number,\n  snapsAligned: number[],\n  containScroll: ScrollContainOptionType,\n): ScrollContainType {\n  const scrollBounds = Limit(-contentSize + viewSize, snapsAligned[0])\n  const snapsBounded = snapsAligned.map(scrollBounds.constrain)\n  const snapsContained = measureContained()\n\n  function findDuplicates(): LimitType {\n    const startSnap = snapsBounded[0]\n    const endSnap = arrayLast(snapsBounded)\n    const min = snapsBounded.lastIndexOf(startSnap)\n    const max = snapsBounded.indexOf(endSnap) + 1\n    return Limit(min, max)\n  }\n\n  function measureContained(): number[] {\n    if (contentSize <= viewSize) return [scrollBounds.max]\n    if (containScroll === 'keepSnaps') return snapsBounded\n    const { min, max } = findDuplicates()\n    return snapsBounded.slice(min, max)\n  }\n\n  const self: ScrollContainType = {\n    snapsContained,\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { arrayLast } from './utils'\n\nexport type ScrollLimitType = {\n  limit: LimitType\n}\n\nexport function ScrollLimit(\n  contentSize: number,\n  scrollSnaps: number[],\n  loop: boolean,\n): ScrollLimitType {\n  const limit = measureLimit()\n\n  function measureLimit(): LimitType {\n    const startSnap = scrollSnaps[0]\n    const endSnap = arrayLast(scrollSnaps)\n    const min = loop ? startSnap - contentSize : endSnap\n    const max = startSnap\n    return Limit(min, max)\n  }\n\n  const self: ScrollLimitType = {\n    limit,\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollLooperType = {\n  loop: (direction: number) => void\n}\n\nexport function ScrollLooper(\n  contentSize: number,\n  limit: LimitType,\n  location: Vector1DType,\n  vectors: Vector1DType[],\n): ScrollLooperType {\n  const jointSafety = 0.1\n  const min = limit.min + jointSafety\n  const max = limit.max + jointSafety\n  const { reachedMin, reachedMax } = Limit(min, max)\n\n  function shouldLoop(direction: number): boolean {\n    if (direction === 1) return reachedMax(location.get())\n    if (direction === -1) return reachedMin(location.get())\n    return false\n  }\n\n  function loop(direction: number): void {\n    if (!shouldLoop(direction)) return\n\n    const loopDistance = contentSize * (direction * -1)\n    vectors.forEach((v) => v.add(loopDistance))\n  }\n\n  const self: ScrollLooperType = {\n    loop,\n  }\n  return self\n}\n","import { LimitType } from './Limit'\n\nexport type ScrollProgressType = {\n  get: (n: number) => number\n}\n\nexport function ScrollProgress(limit: LimitType): ScrollProgressType {\n  const { max, length: scrollLength } = limit\n\n  function get(n: number): number {\n    const currentLocation = n - max\n    return currentLocation / -scrollLength\n  }\n\n  const self: ScrollProgressType = {\n    get,\n  }\n  return self\n}\n","import { AlignmentType } from './Alignment'\nimport { AxisType } from './Axis'\nimport { SlidesToScrollType } from './SlidesToScroll'\nimport { arrayLast, arrayLastIndex, mathAbs } from './utils'\n\nexport type ScrollSnapsType = {\n  snaps: number[]\n  snapsAligned: number[]\n}\n\nexport function ScrollSnaps(\n  axis: AxisType,\n  alignment: AlignmentType,\n  containerRect: DOMRect,\n  slideRects: DOMRect[],\n  slideSizesWithGaps: number[],\n  slidesToScroll: SlidesToScrollType,\n  containScroll: boolean,\n): ScrollSnapsType {\n  const { startEdge, endEdge } = axis\n  const { groupSlides } = slidesToScroll\n  const alignments = measureSizes().map(alignment.measure)\n  const snaps = measureUnaligned()\n  const snapsAligned = measureAligned()\n\n  function measureSizes(): number[] {\n    return groupSlides(slideRects)\n      .map((rects) => arrayLast(rects)[endEdge] - rects[0][startEdge])\n      .map(mathAbs)\n  }\n\n  function measureUnaligned(): number[] {\n    return slideRects\n      .map((rect) => containerRect[startEdge] - rect[startEdge])\n      .map((snap) => -mathAbs(snap))\n  }\n\n  function measureAligned(): number[] {\n    const containedStartSnap = 0\n    const containedEndSnap = arrayLast(snaps) - arrayLast(slideSizesWithGaps)\n\n    return groupSlides(snaps)\n      .map((g) => g[0])\n      .map((snap, index, groupedSnaps) => {\n        const isFirst = !index\n        const isLast = index === arrayLastIndex(groupedSnaps)\n        if (containScroll && isFirst) return containedStartSnap\n        if (containScroll && isLast) return containedEndSnap\n        return snap + alignments[index]\n      })\n  }\n\n  const self: ScrollSnapsType = {\n    snaps,\n    snapsAligned,\n  }\n  return self\n}\n","import { LimitType } from './Limit'\nimport { Vector1DType } from './Vector1d'\nimport { mathAbs, mathSign } from './utils'\n\nexport type TargetType = {\n  distance: number\n  index: number\n}\n\nexport type ScrollTargetType = {\n  byIndex: (target: number, direction: number) => TargetType\n  byDistance: (force: number, snap: boolean) => TargetType\n  shortcut: (target: number, direction: number) => number\n}\n\nexport function ScrollTarget(\n  loop: boolean,\n  scrollSnaps: number[],\n  contentSize: number,\n  limit: LimitType,\n  targetVector: Vector1DType,\n): ScrollTargetType {\n  const { reachedAny, removeOffset, constrain } = limit\n\n  function minDistance(distances: number[]): number {\n    return distances.concat().sort((a, b) => mathAbs(a) - mathAbs(b))[0]\n  }\n\n  function findTargetSnap(target: number): TargetType {\n    const distance = loop ? removeOffset(target) : constrain(target)\n    const ascDiffsToSnaps = scrollSnaps\n      .map((scrollSnap) => scrollSnap - distance)\n      .map((diffToSnap) => shortcut(diffToSnap, 0))\n      .map((diff, i) => ({ diff, index: i }))\n      .sort((d1, d2) => mathAbs(d1.diff) - mathAbs(d2.diff))\n\n    const { index } = ascDiffsToSnaps[0]\n    return { index, distance }\n  }\n\n  function shortcut(target: number, direction: number): number {\n    const targets = [target, target + contentSize, target - contentSize]\n\n    if (!loop) return targets[0]\n    if (!direction) return minDistance(targets)\n\n    const matchingTargets = targets.filter((t) => mathSign(t) === direction)\n    return minDistance(matchingTargets)\n  }\n\n  function byIndex(index: number, direction: number): TargetType {\n    const diffToSnap = scrollSnaps[index] - targetVector.get()\n    const distance = shortcut(diffToSnap, direction)\n    return { index, distance }\n  }\n\n  function byDistance(distance: number, snap: boolean): TargetType {\n    const target = targetVector.get() + distance\n    const { index, distance: targetSnapDistance } = findTargetSnap(target)\n    const reachedBound = !loop && reachedAny(target)\n\n    if (!snap || reachedBound) return { index, distance }\n\n    const diffToSnap = scrollSnaps[index] - targetSnapDistance\n    const snapDistance = distance + shortcut(diffToSnap, 0)\n\n    return { index, distance: snapDistance }\n  }\n\n  const self: ScrollTargetType = {\n    byDistance,\n    byIndex,\n    shortcut,\n  }\n  return self\n}\n","import { AnimationType } from './Animation'\nimport { CounterType } from './Counter'\nimport { EventHandlerType } from './EventHandler'\nimport { ScrollTargetType, TargetType } from './ScrollTarget'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollToType = {\n  distance: (n: number, snap: boolean) => void\n  index: (n: number, direction: number) => void\n}\n\nexport function ScrollTo(\n  animation: AnimationType,\n  indexCurrent: CounterType,\n  indexPrevious: CounterType,\n  scrollTarget: ScrollTargetType,\n  targetVector: Vector1DType,\n  eventHandler: EventHandlerType,\n): ScrollToType {\n  function scrollTo(target: TargetType): void {\n    const distanceDiff = target.distance\n    const indexDiff = target.index !== indexCurrent.get()\n\n    if (distanceDiff) {\n      animation.start()\n      targetVector.add(distanceDiff)\n    }\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get())\n      indexCurrent.set(target.index)\n      eventHandler.emit('select')\n    }\n  }\n\n  function distance(n: number, snap: boolean): void {\n    const target = scrollTarget.byDistance(n, snap)\n    scrollTo(target)\n  }\n\n  function index(n: number, direction: number): void {\n    const targetIndex = indexCurrent.clone().set(n)\n    const target = scrollTarget.byIndex(targetIndex.get(), direction)\n    scrollTo(target)\n  }\n\n  const self: ScrollToType = {\n    distance,\n    index,\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { DirectionType } from './Direction'\nimport { Vector1DType } from './Vector1d'\n\nexport type TranslateType = {\n  clear: () => void\n  to: (vector: Vector1DType) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function Translate(\n  axis: AxisType,\n  direction: DirectionType,\n  container: HTMLElement,\n): TranslateType {\n  const translate = axis.scroll === 'x' ? x : y\n  const containerStyle = container.style\n  let disabled = false\n\n  function x(n: number): string {\n    return `translate3d(${n}px,0px,0px)`\n  }\n\n  function y(n: number): string {\n    return `translate3d(0px,${n}px,0px)`\n  }\n\n  function to(target: Vector1DType): void {\n    if (disabled) return\n    containerStyle.transform = translate(direction.apply(target.get()))\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  function clear(): void {\n    if (disabled) return\n    containerStyle.transform = ''\n    if (!container.getAttribute('style')) container.removeAttribute('style')\n  }\n\n  const self: TranslateType = {\n    clear,\n    to,\n    toggleActive,\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { arrayKeys } from './utils'\nimport { SlidesInViewType } from './SlidesInView'\nimport { Vector1D, Vector1DType } from './Vector1d'\nimport { Translate, TranslateType } from './Translate'\nimport { DirectionType } from './Direction'\n\ntype EdgeType = 'start' | 'end'\n\ntype LoopPointType = {\n  index: number\n  translate: TranslateType\n  location: Vector1DType\n  target: () => Vector1DType\n}\n\nexport type SlideLooperType = {\n  canLoop: () => boolean\n  clear: () => void\n  loop: () => void\n  loopPoints: LoopPointType[]\n}\n\nexport function SlideLooper(\n  axis: AxisType,\n  direction: DirectionType,\n  viewSize: number,\n  contentSize: number,\n  slideSizesWithGaps: number[],\n  scrollSnaps: number[],\n  slidesInView: SlidesInViewType,\n  scroll: Vector1DType,\n  slides: HTMLElement[],\n): SlideLooperType {\n  const ascItems = arrayKeys(slideSizesWithGaps)\n  const descItems = arrayKeys(slideSizesWithGaps).reverse()\n  const loopPoints = startPoints().concat(endPoints())\n\n  function removeSlideSizes(indexes: number[], from: number): number {\n    return indexes.reduce((a: number, i) => {\n      return a - slideSizesWithGaps[i]\n    }, from)\n  }\n\n  function slidesInGap(indexes: number[], gap: number): number[] {\n    return indexes.reduce((a: number[], i) => {\n      const remainingGap = removeSlideSizes(a, gap)\n      return remainingGap > 0 ? a.concat([i]) : a\n    }, [])\n  }\n\n  function findLoopPoints(indexes: number[], edge: EdgeType): LoopPointType[] {\n    const isStartEdge = edge === 'start'\n    const offset = isStartEdge ? -contentSize : contentSize\n    const slideBounds = slidesInView.findSlideBounds([offset])\n\n    return indexes.map((index) => {\n      const initial = isStartEdge ? 0 : -contentSize\n      const altered = isStartEdge ? contentSize : 0\n      const bounds = slideBounds.filter((b) => b.index === index)[0]\n      const point = bounds[isStartEdge ? 'end' : 'start']\n      const shift = Vector1D(-1)\n      const location = Vector1D(-1)\n      const translate = Translate(axis, direction, slides[index])\n      const target = () => shift.set(scroll.get() > point ? initial : altered)\n      return { index, location, translate, target }\n    })\n  }\n\n  function startPoints(): LoopPointType[] {\n    const gap = scrollSnaps[0] - 1\n    const indexes = slidesInGap(descItems, gap)\n    return findLoopPoints(indexes, 'end')\n  }\n\n  function endPoints(): LoopPointType[] {\n    const gap = viewSize - scrollSnaps[0] - 1\n    const indexes = slidesInGap(ascItems, gap)\n    return findLoopPoints(indexes, 'start')\n  }\n\n  function canLoop(): boolean {\n    return loopPoints.every(({ index }) => {\n      const otherIndexes = ascItems.filter((i) => i !== index)\n      return removeSlideSizes(otherIndexes, viewSize) <= 0.1\n    })\n  }\n\n  function loop(): void {\n    loopPoints.forEach((loopPoint) => {\n      const { target, translate, location } = loopPoint\n      const shift = target()\n      if (shift.get() === location.get()) return\n      if (shift.get() === 0) translate.clear()\n      else translate.to(shift)\n      location.set(shift)\n    })\n  }\n\n  function clear(): void {\n    loopPoints.forEach((loopPoint) => loopPoint.translate.clear())\n  }\n\n  const self: SlideLooperType = {\n    canLoop,\n    clear,\n    loop,\n    loopPoints,\n  }\n  return self\n}\n","import { Limit, LimitType } from './Limit'\n\nexport type SlideBoundType = {\n  start: number\n  end: number\n  index: number\n}\n\nexport type SlidesInViewType = {\n  check: (location: number, bounds?: SlideBoundType[]) => number[]\n  findSlideBounds: (offsets?: number[], threshold?: number) => SlideBoundType[]\n}\n\nexport function SlidesInView(\n  viewSize: number,\n  contentSize: number,\n  slideSizes: number[],\n  snaps: number[],\n  limit: LimitType,\n  loop: boolean,\n  inViewThreshold: number,\n): SlidesInViewType {\n  const { removeOffset, constrain } = limit\n  const roundingSafety = 0.5\n  const cachedOffsets = loop ? [0, contentSize, -contentSize] : [0]\n  const cachedBounds = findSlideBounds(cachedOffsets, inViewThreshold)\n\n  function findSlideThresholds(threshold?: number): number[] {\n    const slideThreshold = threshold || 0\n\n    return slideSizes.map((slideSize) => {\n      const thresholdLimit = Limit(roundingSafety, slideSize - roundingSafety)\n      return thresholdLimit.constrain(slideSize * slideThreshold)\n    })\n  }\n\n  function findSlideBounds(\n    offsets?: number[],\n    threshold?: number,\n  ): SlideBoundType[] {\n    const slideOffsets = offsets || cachedOffsets\n    const slideThresholds = findSlideThresholds(threshold)\n\n    return slideOffsets.reduce((list: SlideBoundType[], offset) => {\n      const bounds = snaps.map((snap, index) => ({\n        start: snap - slideSizes[index] + slideThresholds[index] + offset,\n        end: snap + viewSize - slideThresholds[index] + offset,\n        index,\n      }))\n      return list.concat(bounds)\n    }, [])\n  }\n\n  function check(location: number, bounds?: SlideBoundType[]): number[] {\n    const limitedLocation = loop ? removeOffset(location) : constrain(location)\n    const slideBounds = bounds || cachedBounds\n\n    return slideBounds.reduce((list: number[], slideBound) => {\n      const { index, start, end } = slideBound\n      const inList = list.indexOf(index) !== -1\n      const inView = start < limitedLocation && end > limitedLocation\n      return !inList && inView ? list.concat([index]) : list\n    }, [])\n  }\n\n  const self: SlidesInViewType = {\n    check,\n    findSlideBounds,\n  }\n  return self\n}\n","import { AxisType } from './Axis'\nimport { arrayLast, arrayLastIndex, mathAbs } from './utils'\n\nexport type SlideSizesType = {\n  slideSizes: number[]\n  slideSizesWithGaps: number[]\n}\n\nexport function SlideSizes(\n  axis: AxisType,\n  containerRect: DOMRect,\n  slideRects: DOMRect[],\n  slides: HTMLElement[],\n  includeEdgeGap: boolean,\n): SlideSizesType {\n  const { measureSize, startEdge, endEdge } = axis\n  const startGap = measureStartGap()\n  const endGap = measureEndGap()\n  const slideSizes = slideRects.map(measureSize)\n  const slideSizesWithGaps = measureWithGaps()\n\n  function measureStartGap(): number {\n    if (!includeEdgeGap) return 0\n    const slideRect = slideRects[0]\n    return mathAbs(containerRect[startEdge] - slideRect[startEdge])\n  }\n\n  function measureEndGap(): number {\n    if (!includeEdgeGap) return 0\n    const style = window.getComputedStyle(arrayLast(slides))\n    return parseFloat(style.getPropertyValue(`margin-${endEdge}`))\n  }\n\n  function measureWithGaps(): number[] {\n    return slideRects\n      .map((rect, index, rects) => {\n        const isFirst = !index\n        const isLast = index === arrayLastIndex(rects)\n        if (isFirst) return slideSizes[index] + startGap\n        if (isLast) return slideSizes[index] + endGap\n        return rects[index + 1][startEdge] - rect[startEdge]\n      })\n      .map(mathAbs)\n  }\n\n  const self: SlideSizesType = {\n    slideSizes,\n    slideSizesWithGaps,\n  }\n  return self\n}\n","import { arrayKeys, arrayLast, isNumber } from './utils'\n\nexport type SlidesToScrollOptionType = 'auto' | number\n\nexport type SlidesToScrollType = {\n  groupSlides: <Type>(array: Type[]) => Type[][]\n}\n\nexport function SlidesToScroll(\n  viewSize: number,\n  slideSizesWithGaps: number[],\n  slidesToScroll: SlidesToScrollOptionType,\n): SlidesToScrollType {\n  const groupByNumber = isNumber(slidesToScroll)\n\n  function byNumber<Type>(array: Type[], groupSize: number): Type[][] {\n    return arrayKeys(array)\n      .filter((i) => i % groupSize === 0)\n      .map((i) => array.slice(i, i + groupSize))\n  }\n\n  function bySize<Type>(array: Type[]): Type[][] {\n    return arrayKeys(array)\n      .reduce((groupSizes: number[], i) => {\n        const chunk = slideSizesWithGaps.slice(arrayLast(groupSizes), i + 1)\n        const chunkSize = chunk.reduce((a, s) => a + s, 0)\n        return !i || chunkSize > viewSize ? groupSizes.concat(i) : groupSizes\n      }, [])\n      .map((start, i, groupSizes) => array.slice(start, groupSizes[i + 1]))\n  }\n\n  function groupSlides<Type>(array: Type[]): Type[][] {\n    return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array)\n  }\n\n  const self: SlidesToScrollType = {\n    groupSlides,\n  }\n  return self\n}\n","import { Alignment } from './Alignment'\nimport { Animation, AnimationType } from './Animation'\nimport { Axis, AxisType } from './Axis'\nimport { Counter, CounterType } from './Counter'\nimport { Direction, DirectionType } from './Direction'\nimport { DragHandler, DragHandlerType } from './DragHandler'\nimport { DragTracker } from './DragTracker'\nimport { EventHandlerType } from './EventHandler'\nimport { EventStore, EventStoreType } from './EventStore'\nimport { LimitType } from './Limit'\nimport { OptionsType } from './Options'\nimport { PercentOfView, PercentOfViewType } from './PercentOfView'\nimport { ScrollBody, ScrollBodyType } from './ScrollBody'\nimport { ScrollBounds, ScrollBoundsType } from './ScrollBounds'\nimport { ScrollContain } from './ScrollContain'\nimport { ScrollLimit } from './ScrollLimit'\nimport { ScrollLooper, ScrollLooperType } from './ScrollLooper'\nimport { ScrollProgress, ScrollProgressType } from './ScrollProgress'\nimport { ScrollSnaps } from './ScrollSnaps'\nimport { ScrollTarget, ScrollTargetType } from './ScrollTarget'\nimport { ScrollTo, ScrollToType } from './ScrollTo'\nimport { SlideLooper, SlideLooperType } from './SlideLooper'\nimport { SlidesInView, SlidesInViewType } from './SlidesInView'\nimport { SlideSizes } from './SlideSizes'\nimport { SlidesToScroll, SlidesToScrollType } from './SlidesToScroll'\nimport { Translate, TranslateType } from './Translate'\nimport { arrayKeys, arrayLast, arrayLastIndex } from './utils'\nimport { Vector1D, Vector1DType } from './Vector1d'\n\nexport type EngineType = {\n  axis: AxisType\n  direction: DirectionType\n  animation: AnimationType\n  scrollBounds: ScrollBoundsType\n  scrollLooper: ScrollLooperType\n  scrollProgress: ScrollProgressType\n  index: CounterType\n  indexPrevious: CounterType\n  limit: LimitType\n  location: Vector1DType\n  options: OptionsType\n  percentOfView: PercentOfViewType\n  scrollBody: ScrollBodyType\n  dragHandler: DragHandlerType\n  eventStore: EventStoreType\n  slideLooper: SlideLooperType\n  slidesInView: SlidesInViewType\n  slidesToScroll: SlidesToScrollType\n  target: Vector1DType\n  translate: TranslateType\n  scrollTo: ScrollToType\n  scrollTarget: ScrollTargetType\n  scrollSnaps: number[]\n  slideIndexes: number[]\n  containerRect: DOMRect\n  slideRects: DOMRect[]\n}\n\nexport function Engine(\n  root: HTMLElement,\n  container: HTMLElement,\n  slides: HTMLElement[],\n  options: OptionsType,\n  eventHandler: EventHandlerType,\n): EngineType {\n  // Options\n  const {\n    align,\n    axis: scrollAxis,\n    direction: contentDirection,\n    startIndex,\n    inViewThreshold,\n    loop,\n    speed,\n    dragFree,\n    slidesToScroll: groupSlides,\n    skipSnaps,\n    containScroll,\n  } = options\n\n  // Measurements\n  const containerRect = container.getBoundingClientRect()\n  const slideRects = slides.map((slide) => slide.getBoundingClientRect())\n  const direction = Direction(contentDirection)\n  const axis = Axis(scrollAxis, contentDirection)\n  const viewSize = axis.measureSize(containerRect)\n  const percentOfView = PercentOfView(viewSize)\n  const alignment = Alignment(align, viewSize)\n  const containSnaps = !loop && containScroll !== ''\n  const includeEdgeGap = loop || containScroll !== ''\n  const { slideSizes, slideSizesWithGaps } = SlideSizes(\n    axis,\n    containerRect,\n    slideRects,\n    slides,\n    includeEdgeGap,\n  )\n  const slidesToScroll = SlidesToScroll(\n    viewSize,\n    slideSizesWithGaps,\n    groupSlides,\n  )\n  const { snaps, snapsAligned } = ScrollSnaps(\n    axis,\n    alignment,\n    containerRect,\n    slideRects,\n    slideSizesWithGaps,\n    slidesToScroll,\n    containSnaps,\n  )\n  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps)\n  const { snapsContained } = ScrollContain(\n    viewSize,\n    contentSize,\n    snapsAligned,\n    containScroll,\n  )\n  const scrollSnaps = containSnaps ? snapsContained : snapsAligned\n  const { limit } = ScrollLimit(contentSize, scrollSnaps, loop)\n\n  // Indexes\n  const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop)\n  const indexPrevious = index.clone()\n  const slideIndexes = arrayKeys(slides)\n\n  // Draw\n  const update = (): void => {\n    if (!loop) engine.scrollBounds.constrain(engine.dragHandler.pointerDown())\n    engine.scrollBody.seek(target).update()\n    const settled = engine.scrollBody.settle(target)\n\n    if (settled && !engine.dragHandler.pointerDown()) {\n      engine.animation.stop()\n      eventHandler.emit('settle')\n    }\n    if (!settled) {\n      eventHandler.emit('scroll')\n    }\n    if (loop) {\n      engine.scrollLooper.loop(engine.scrollBody.direction())\n      engine.slideLooper.loop()\n    }\n\n    engine.translate.to(location)\n    engine.animation.proceed()\n  }\n\n  // Shared\n  const animation = Animation(update)\n  const startLocation = scrollSnaps[index.get()]\n  const location = Vector1D(startLocation)\n  const target = Vector1D(startLocation)\n  const scrollBody = ScrollBody(location, speed, 1)\n  const scrollTarget = ScrollTarget(\n    loop,\n    scrollSnaps,\n    contentSize,\n    limit,\n    target,\n  )\n  const scrollTo = ScrollTo(\n    animation,\n    index,\n    indexPrevious,\n    scrollTarget,\n    target,\n    eventHandler,\n  )\n  const slidesInView = SlidesInView(\n    viewSize,\n    contentSize,\n    slideSizes,\n    snaps,\n    limit,\n    loop,\n    inViewThreshold,\n  )\n\n  // DragHandler\n  const dragHandler = DragHandler(\n    axis,\n    direction,\n    root,\n    target,\n    DragTracker(axis),\n    location,\n    animation,\n    scrollTo,\n    scrollBody,\n    scrollTarget,\n    index,\n    eventHandler,\n    percentOfView,\n    loop,\n    dragFree,\n    skipSnaps,\n  )\n\n  // Engine\n  const engine: EngineType = {\n    containerRect,\n    slideRects,\n    animation,\n    axis,\n    direction,\n    dragHandler,\n    eventStore: EventStore(),\n    percentOfView,\n    index,\n    indexPrevious,\n    limit,\n    location,\n    options,\n    scrollBody,\n    scrollBounds: ScrollBounds(\n      limit,\n      location,\n      target,\n      scrollBody,\n      percentOfView,\n    ),\n    scrollLooper: ScrollLooper(contentSize, limit, location, [\n      location,\n      target,\n    ]),\n    scrollProgress: ScrollProgress(limit),\n    scrollSnaps,\n    scrollTarget,\n    scrollTo,\n    slideLooper: SlideLooper(\n      axis,\n      direction,\n      viewSize,\n      contentSize,\n      slideSizesWithGaps,\n      scrollSnaps,\n      slidesInView,\n      location,\n      slides,\n    ),\n    slidesToScroll,\n    slidesInView,\n    slideIndexes,\n    target,\n    translate: Translate(axis, direction, container),\n  }\n  return engine\n}\n","type CallbackType = (evt: EmblaEventType) => void\ntype ListenersType = Partial<{ [key in EmblaEventType]: CallbackType[] }>\n\nexport type EmblaEventType =\n  | 'init'\n  | 'pointerDown'\n  | 'pointerUp'\n  | 'scroll'\n  | 'select'\n  | 'settle'\n  | 'destroy'\n  | 'reInit'\n  | 'resize'\n\nexport type EventHandlerType = {\n  emit: (evt: EmblaEventType) => EventHandlerType\n  on: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType\n  off: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType\n}\n\nexport function EventHandler(): EventHandlerType {\n  const listeners: ListenersType = {}\n\n  function getListeners(evt: EmblaEventType): CallbackType[] {\n    return listeners[evt] || []\n  }\n\n  function emit(evt: EmblaEventType): EventHandlerType {\n    getListeners(evt).forEach((e) => e(evt))\n    return self\n  }\n\n  function on(evt: EmblaEventType, cb: CallbackType): EventHandlerType {\n    listeners[evt] = getListeners(evt).concat([cb])\n    return self\n  }\n\n  function off(evt: EmblaEventType, cb: CallbackType): EventHandlerType {\n    listeners[evt] = getListeners(evt).filter((e) => e !== cb)\n    return self\n  }\n\n  const self: EventHandlerType = {\n    emit,\n    off,\n    on,\n  }\n  return self\n}\n","import { AlignmentOptionType } from './Alignment'\nimport { AxisOptionType } from './Axis'\nimport { SlidesToScrollOptionType } from './SlidesToScroll'\nimport { DirectionOptionType } from './Direction'\nimport { ScrollContainOptionType } from './ScrollContain'\n\nexport type LooseOptionsType = {\n  [key: string]: unknown\n}\n\nexport type CreateOptionsType<Type extends LooseOptionsType> = Type & {\n  active: boolean\n  breakpoints: {\n    [key: string]: Omit<Partial<CreateOptionsType<Type>>, 'breakpoints'>\n  }\n}\n\nexport type OptionsType = CreateOptionsType<{\n  align: AlignmentOptionType\n  axis: AxisOptionType\n  containScroll: ScrollContainOptionType\n  direction: DirectionOptionType\n  slidesToScroll: SlidesToScrollOptionType\n  dragFree: boolean\n  draggable: boolean\n  inViewThreshold: number\n  loop: boolean\n  skipSnaps: boolean\n  speed: number\n  startIndex: number\n}>\n\nexport const defaultOptions: OptionsType = {\n  align: 'center',\n  axis: 'x',\n  containScroll: '',\n  direction: 'ltr',\n  slidesToScroll: 1,\n  breakpoints: {},\n  dragFree: false,\n  draggable: true,\n  inViewThreshold: 0,\n  loop: false,\n  skipSnaps: false,\n  speed: 10,\n  startIndex: 0,\n  active: true,\n}\n\nexport type EmblaOptionsType = Partial<OptionsType>\n","import { LooseOptionsType, CreateOptionsType } from './Options'\nimport { objectKeys, objectsAreEqual, objectsMergeDeep } from './utils'\n\ntype OptionsType = Partial<CreateOptionsType<LooseOptionsType>>\n\nexport type OptionsHandlerType = {\n  merge: <TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB?: TypeB,\n  ) => TypeA\n  areEqual: <TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB: TypeB,\n  ) => boolean\n  atMedia: <Type extends OptionsType>(options: Type) => Type\n}\n\nexport function OptionsHandler(): OptionsHandlerType {\n  function merge<TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB?: TypeB,\n  ): TypeA {\n    return <TypeA>objectsMergeDeep(optionsA, optionsB || {})\n  }\n\n  function areEqual<TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB: TypeB,\n  ): boolean {\n    const breakpointsA = JSON.stringify(objectKeys(optionsA.breakpoints || {}))\n    const breakpointsB = JSON.stringify(objectKeys(optionsB.breakpoints || {}))\n    if (breakpointsA !== breakpointsB) return false\n    return objectsAreEqual(optionsA, optionsB)\n  }\n\n  function atMedia<Type extends OptionsType>(options: Type): Type {\n    const optionsAtMedia = options.breakpoints || {}\n    const matchedMediaOptions = objectKeys(optionsAtMedia)\n      .filter((media) => window.matchMedia(media).matches)\n      .map((media) => optionsAtMedia[media])\n      .reduce((a, mediaOption) => merge(a, mediaOption), {})\n\n    return merge(options, matchedMediaOptions)\n  }\n\n  const self: OptionsHandlerType = {\n    merge,\n    areEqual,\n    atMedia,\n  }\n  return self\n}\n","import { EmblaCarouselType } from '.'\nimport { OptionsHandler } from './OptionsHandler'\nimport { EmblaPluginsType, EmblaPluginType } from './Plugins'\n\ntype PluginChangedHandlerType = () => boolean\n\nexport type PluginsHandlerType = {\n  init: (\n    plugins: EmblaPluginType[],\n    embla: EmblaCarouselType,\n  ) => EmblaPluginsType\n  destroy: () => void\n  haveChanged: PluginChangedHandlerType\n}\n\nexport function PluginsHandler(): PluginsHandlerType {\n  const { atMedia, areEqual } = OptionsHandler()\n  let activePlugins: EmblaPluginType[] = []\n  let pluginsChanged: PluginChangedHandlerType[] = []\n\n  function haveChanged(): boolean {\n    return pluginsChanged.some((hasChanged) => hasChanged())\n  }\n\n  function hasChanged(plugin: EmblaPluginType): PluginChangedHandlerType {\n    const options = atMedia(plugin.options)\n    return (): boolean => !areEqual(options, atMedia(plugin.options))\n  }\n\n  function init(\n    plugins: EmblaPluginType[],\n    embla: EmblaCarouselType,\n  ): EmblaPluginsType {\n    pluginsChanged = plugins.map(hasChanged)\n    activePlugins = plugins.filter((plugin) => atMedia(plugin.options).active)\n    activePlugins.forEach((plugin) => plugin.init(embla))\n\n    return plugins.reduce((map, plugin) => {\n      return Object.assign(map, { [plugin.name]: plugin })\n    }, {})\n  }\n\n  function destroy(): void {\n    activePlugins = activePlugins.filter((plugin) => plugin.destroy())\n  }\n\n  const self: PluginsHandlerType = {\n    init,\n    destroy,\n    haveChanged,\n  }\n  return self\n}\n","import { Engine, EngineType } from './Engine'\nimport { EventStore } from './EventStore'\nimport { EventHandler, EventHandlerType } from './EventHandler'\nimport { defaultOptions, EmblaOptionsType } from './Options'\nimport { OptionsHandler } from './OptionsHandler'\nimport { PluginsHandler } from './PluginsHandler'\nimport { EmblaPluginsType, EmblaPluginType } from './Plugins'\n\nexport type EmblaNodesType = {\n  root: HTMLElement\n  container?: HTMLElement\n  slides?: HTMLElement[]\n}\n\nexport type EmblaCarouselType = {\n  canScrollNext: () => boolean\n  canScrollPrev: () => boolean\n  clickAllowed: () => boolean\n  containerNode: () => HTMLElement\n  internalEngine: () => EngineType\n  destroy: () => void\n  off: EventHandlerType['off']\n  on: EventHandlerType['on']\n  plugins: () => EmblaPluginsType\n  previousScrollSnap: () => number\n  reInit: (options?: EmblaOptionsType, plugins?: EmblaPluginType[]) => void\n  rootNode: () => HTMLElement\n  scrollNext: (jump?: boolean) => void\n  scrollPrev: (jump?: boolean) => void\n  scrollProgress: () => number\n  scrollSnapList: () => number[]\n  scrollTo: (index: number, jump?: boolean) => void\n  selectedScrollSnap: () => number\n  slideNodes: () => HTMLElement[]\n  slidesInView: (target?: boolean) => number[]\n  slidesNotInView: (target?: boolean) => number[]\n}\n\nfunction EmblaCarousel(\n  nodes: HTMLElement | EmblaNodesType,\n  userOptions?: EmblaOptionsType,\n  userPlugins?: EmblaPluginType[],\n): EmblaCarouselType {\n  const resizeHandlers = EventStore()\n  const optionsHandler = OptionsHandler()\n  const pluginsHandler = PluginsHandler()\n  const eventHandler = EventHandler()\n  const { on, off } = eventHandler\n  const reInit = reActivate\n\n  let destroyed = false\n  let engine: EngineType\n  let optionsBase = optionsHandler.merge(\n    defaultOptions,\n    EmblaCarousel.globalOptions,\n  )\n  let options = optionsHandler.merge(optionsBase)\n  let pluginList: EmblaPluginType[] = []\n  let pluginApis: EmblaPluginsType\n  let rootSize = 0\n  let root: HTMLElement\n  let container: HTMLElement\n  let slides: HTMLElement[]\n\n  function storeElements(): void {\n    const providedContainer = 'container' in nodes && nodes.container\n    const providedSlides = 'slides' in nodes && nodes.slides\n\n    root = 'root' in nodes ? nodes.root : nodes\n    container = providedContainer || <HTMLElement>root.children[0]\n    slides = providedSlides || [].slice.call(container.children)\n  }\n\n  function activate(\n    withOptions?: EmblaOptionsType,\n    withPlugins?: EmblaPluginType[],\n  ): void {\n    if (destroyed) return\n    storeElements()\n\n    optionsBase = optionsHandler.merge(optionsBase, withOptions)\n    options = optionsHandler.atMedia(optionsBase)\n    engine = Engine(root, container, slides, options, eventHandler)\n    rootSize = engine.axis.measureSize(root.getBoundingClientRect())\n\n    if (!options.active) return deActivate()\n\n    engine.translate.to(engine.location)\n    pluginList = withPlugins || pluginList\n    pluginApis = pluginsHandler.init(pluginList, self)\n\n    if (options.loop) {\n      if (!engine.slideLooper.canLoop()) {\n        deActivate()\n        return activate({ loop: false }, withPlugins)\n      }\n      engine.slideLooper.loop()\n    }\n    if (options.draggable && container.offsetParent && slides.length) {\n      engine.dragHandler.addActivationEvents()\n    }\n  }\n\n  function reActivate(\n    withOptions?: EmblaOptionsType,\n    withPlugins?: EmblaPluginType[],\n  ): void {\n    const startIndex = selectedScrollSnap()\n    deActivate()\n    activate(optionsHandler.merge({ startIndex }, withOptions), withPlugins)\n    eventHandler.emit('reInit')\n  }\n\n  function deActivate(): void {\n    engine.dragHandler.removeAllEvents()\n    engine.animation.stop()\n    engine.eventStore.removeAll()\n    engine.translate.clear()\n    engine.slideLooper.clear()\n    pluginsHandler.destroy()\n  }\n\n  function destroy(): void {\n    if (destroyed) return\n    destroyed = true\n    resizeHandlers.removeAll()\n    deActivate()\n    eventHandler.emit('destroy')\n  }\n\n  function resize(): void {\n    const newOptions = optionsHandler.atMedia(optionsBase)\n    const optionsChanged = !optionsHandler.areEqual(newOptions, options)\n    const newRootSize = engine.axis.measureSize(root.getBoundingClientRect())\n    const rootSizeChanged = rootSize !== newRootSize\n    const pluginsChanged = pluginsHandler.haveChanged()\n\n    if (rootSizeChanged || optionsChanged || pluginsChanged) reActivate()\n    eventHandler.emit('resize')\n  }\n\n  function slidesInView(target?: boolean): number[] {\n    const location = engine[target ? 'target' : 'location'].get()\n    const type = options.loop ? 'removeOffset' : 'constrain'\n    return engine.slidesInView.check(engine.limit[type](location))\n  }\n\n  function slidesNotInView(target?: boolean): number[] {\n    const inView = slidesInView(target)\n    return engine.slideIndexes.filter((index) => inView.indexOf(index) === -1)\n  }\n\n  function scrollTo(index: number, jump?: boolean, direction?: number): void {\n    if (!options.active || destroyed) return\n    engine.scrollBody.useBaseMass().useSpeed(jump ? 100 : options.speed)\n    engine.scrollTo.index(index, direction || 0)\n  }\n\n  function scrollNext(jump?: boolean): void {\n    const next = engine.index.clone().add(1)\n    scrollTo(next.get(), jump === true, -1)\n  }\n\n  function scrollPrev(jump?: boolean): void {\n    const prev = engine.index.clone().add(-1)\n    scrollTo(prev.get(), jump === true, 1)\n  }\n\n  function canScrollNext(): boolean {\n    const next = engine.index.clone().add(1)\n    return next.get() !== selectedScrollSnap()\n  }\n\n  function canScrollPrev(): boolean {\n    const prev = engine.index.clone().add(-1)\n    return prev.get() !== selectedScrollSnap()\n  }\n\n  function scrollSnapList(): number[] {\n    return engine.scrollSnaps.map(engine.scrollProgress.get)\n  }\n\n  function scrollProgress(): number {\n    return engine.scrollProgress.get(engine.location.get())\n  }\n\n  function selectedScrollSnap(): number {\n    return engine.index.get()\n  }\n\n  function previousScrollSnap(): number {\n    return engine.indexPrevious.get()\n  }\n\n  function clickAllowed(): boolean {\n    return engine.dragHandler.clickAllowed()\n  }\n\n  function plugins(): EmblaPluginsType {\n    return pluginApis\n  }\n\n  function internalEngine(): EngineType {\n    return engine\n  }\n\n  function rootNode(): HTMLElement {\n    return root\n  }\n\n  function containerNode(): HTMLElement {\n    return container\n  }\n\n  function slideNodes(): HTMLElement[] {\n    return slides\n  }\n\n  const self: EmblaCarouselType = {\n    canScrollNext,\n    canScrollPrev,\n    clickAllowed,\n    containerNode,\n    internalEngine,\n    destroy,\n    off,\n    on,\n    plugins,\n    previousScrollSnap,\n    reInit,\n    rootNode,\n    scrollNext,\n    scrollPrev,\n    scrollProgress,\n    scrollSnapList,\n    scrollTo,\n    selectedScrollSnap,\n    slideNodes,\n    slidesInView,\n    slidesNotInView,\n  }\n\n  activate(userOptions, userPlugins)\n  resizeHandlers.add(window, 'resize', resize)\n  setTimeout(() => eventHandler.emit('init'), 0)\n  return self\n}\n\nEmblaCarousel.globalOptions = <EmblaOptionsType | undefined>undefined\nEmblaCarousel.optionsHandler = OptionsHandler\n\nexport default EmblaCarousel\n"],"names":["map","value","iStart","iStop","oStart","oStop","isNumber","subject","isObject","Object","prototype","toString","call","isArray","Array","isRecord","mathAbs","n","Math","abs","mathSign","deltaAbs","valueB","valueA","factorAbs","diff","roundToDecimals","decimalPoints","pow","round","arrayKeys","array","objectKeys","Number","arrayLast","arrayLastIndex","max","length","object","keys","objectsMergeDeep","objectA","objectB","reduce","mergedObjects","currentObject","forEach","key","areObjects","objectsAreEqual","objectAKeys","objectBKeys","every","concat","Alignment","align","viewSize","predefined","start","center","end","percent","measure","self","Animation","callback","animationFrame","ifAnimating","active","cb","window","requestAnimationFrame","stop","cancelAnimationFrame","proceed","Axis","axis","direction","scroll","cross","startEdge","getStartEdge","endEdge","getEndEdge","measureSize","rect","width","height","Limit","min","reachedMin","reachedMax","reachedAny","constrain","removeOffset","ceil","Counter","loop","_a","loopEnd","counter","withinLimit","get","set","add","clone","Direction","sign","apply","EventStore","listeners","node","type","handler","options","addEventListener","push","removeEventListener","removeAll","filter","remove","Vector1D","vector","readNumber","subtract","multiply","divide","normalize","DragHandler","rootNode","target","dragTracker","location","animation","scrollTo","scrollBody","scrollTarget","index","eventHandler","percentOfView","dragFree","skipSnaps","crossAxis","focusNodes","dragStartPoint","activationEvents","interactionEvents","dragThreshold","snapForceBoost","mouse","touch","freeForceBoost","baseSpeed","baseMass","startScroll","startCross","pointerIsDown","preventScroll","preventClick","isMouse","addActivationEvents","undefined","down","up","click","addInteractionEvents","document","move","removeAllEvents","isFocusNode","name","nodeName","indexOf","forceBoost","boost","allowedForce","force","targetChanged","next","isEdge","baseForce","byDistance","distance","byIndex","evt","button","isMoving","clearPreventClick","isNotFocusNode","preventDefault","pointerDown","useBaseMass","useSpeed","readPoint","emit","cancelable","lastScroll","lastCross","diffScroll","diffCross","pointerMove","currentLocation","rawForce","pointerUp","forceFactor","isVigorous","isBelowThreshold","speed","mass","useMass","clickAllowed","DragTracker","logInterval","startEvent","lastEvent","isTouchEvent","TouchEvent","readTime","timeStamp","evtAxis","property","coord","touches","expired","diffDrag","diffTime","isFlick","PercentOfView","ScrollBody","roundToTwoDecimals","velocity","acceleration","attraction","attractionDirection","update","applyForce","seek","magnitude","settle","hasSettled","useBaseSpeed","ScrollBounds","limit","pullBackThreshold","edgeOffsetTolerance","maxFriction","disabled","shouldConstrain","edge","diffToEdge","diffToTarget","friction","toggleActive","ScrollContain","contentSize","snapsAligned","containScroll","scrollBounds","snapsBounded","snapsContained","measureContained","findDuplicates","startSnap","endSnap","lastIndexOf","slice","ScrollLimit","scrollSnaps","measureLimit","ScrollLooper","vectors","jointSafety","shouldLoop","loopDistance","v","ScrollProgress","scrollLength","ScrollSnaps","alignment","containerRect","slideRects","slideSizesWithGaps","slidesToScroll","groupSlides","alignments","measureSizes","snaps","measureUnaligned","measureAligned","rects","snap","containedStartSnap","containedEndSnap","g","groupedSnaps","isFirst","isLast","ScrollTarget","targetVector","minDistance","distances","sort","a","b","findTargetSnap","ascDiffsToSnaps","scrollSnap","diffToSnap","shortcut","i","d1","d2","targets","matchingTargets","t","targetSnapDistance","reachedBound","snapDistance","ScrollTo","indexCurrent","indexPrevious","distanceDiff","indexDiff","targetIndex","Translate","container","translate","x","y","containerStyle","style","to","transform","clear","getAttribute","removeAttribute","SlideLooper","slidesInView","slides","ascItems","descItems","reverse","loopPoints","startPoints","endPoints","removeSlideSizes","indexes","from","slidesInGap","gap","remainingGap","findLoopPoints","isStartEdge","offset","slideBounds","findSlideBounds","initial","altered","bounds","point","shift","canLoop","otherIndexes","loopPoint","SlidesInView","slideSizes","inViewThreshold","roundingSafety","cachedOffsets","cachedBounds","findSlideThresholds","threshold","slideThreshold","slideSize","thresholdLimit","offsets","slideOffsets","slideThresholds","list","check","limitedLocation","slideBound","inList","inView","SlideSizes","includeEdgeGap","startGap","measureStartGap","endGap","measureEndGap","measureWithGaps","slideRect","getComputedStyle","parseFloat","getPropertyValue","SlidesToScroll","groupByNumber","byNumber","groupSize","bySize","groupSizes","chunk","chunkSize","s","Engine","root","scrollAxis","contentDirection","startIndex","getBoundingClientRect","slide","containSnaps","_b","slideIndexes","engine","dragHandler","settled","scrollLooper","slideLooper","startLocation","eventStore","scrollProgress","EventHandler","getListeners","e","on","off","defaultOptions","breakpoints","draggable","OptionsHandler","merge","optionsA","optionsB","areEqual","breakpointsA","JSON","stringify","breakpointsB","atMedia","optionsAtMedia","matchedMediaOptions","media","matchMedia","matches","mediaOption","PluginsHandler","activePlugins","pluginsChanged","haveChanged","some","hasChanged","plugin","init","plugins","embla","assign","destroy","EmblaCarousel","nodes","userOptions","userPlugins","resizeHandlers","optionsHandler","pluginsHandler","reInit","reActivate","destroyed","optionsBase","globalOptions","pluginList","pluginApis","rootSize","storeElements","providedContainer","providedSlides","children","activate","withOptions","withPlugins","deActivate","offsetParent","selectedScrollSnap","resize","newOptions","optionsChanged","newRootSize","rootSizeChanged","slidesNotInView","jump","scrollNext","scrollPrev","prev","canScrollNext","canScrollPrev","scrollSnapList","previousScrollSnap","internalEngine","containerNode","slideNodes","setTimeout"],"version":3,"file":"index.05ef630e.js.map","sourceRoot":"/__parcel_source_root/"}